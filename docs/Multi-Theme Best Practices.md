NOLA Design System: Multi-Theme Best Practices (2025)
Real-World Multi-Theme Implementations (Tailwind + shadcn)
Modern design systems increasingly support multiple themes, and there are several real-world examples to learn from. Tailwind CSS combined with shadcn/ui (a popular Tailwind + Radix UI component set) is a common stack for theming. For instance, Thinkmill’s multi-brand design system uses Tailwind to manage multiple brand themes in one system
thinkmill.com.au
. They structure each brand’s tokens separately and use Tailwind’s presets to swap out the design tokens for a given brand at build time
thinkmill.com.au
. This means a single component library can be “reskinned” for different brands by providing a different token preset, without rewriting components. Another example is DaisyUI, a Tailwind-based UI kit that offers 35 built-in themes. DaisyUI demonstrates how to define theme objects (as color palettes and CSS variables) and let developers toggle themes via a data-theme attribute on the <html> or a parent element
daisyui.com
. Under the hood, it uses semantic color names mapped to CSS custom properties so that switching the theme simply swaps those variables – e.g. bg-base-100 or text-base-content automatically adjust based on the active theme’s definitions
daisyui.com
. This approach avoids needing separate CSS classes per theme and is highly scalable (DaisyUI users can even enable multiple themes simultaneously on different sections of the UI by scoping with data-theme attributes). In the shadcn/ui ecosystem specifically, theming is typically done via the registry/CLI system. Shadcn’s own default style supports light and dark modes out-of-the-box using CSS variables for colors
ui.shadcn.com
ui.shadcn.com
. Developers have extended this with custom themes – e.g. community projects have published JSON files defining “Neon Nights” or “Ghibli” inspired themes that can be installed via the shadcn CLI. The shadcn UI registry encourages this; there’s even an open-source custom registry template that lets teams host their own components and themes for the CLI
github.com
github.com
. A community repository called shadcn-registries collects contributed theme JSON files from different authors, making them easily discoverable
github.com
github.com
. This shows that by 2025 many developers are successfully distributing themes in JSON form for Tailwind+shadcn systems. In summary, successful implementations to look at include: Thinkmill’s multi-brand Tailwind setup (multi-theme tokens with presets), DaisyUI (multiple themes with Tailwind plugin and CSS variables), and the various custom themes in the shadcn UI community (which use the CLI/registry pattern). These examples highlight the importance of structuring theme data in a portable way (like JSON or config objects) so that it can be swapped in and out of the build or installed via CLI.
Structuring Theme Tokens and CSS Variables for Dynamic Themes
Leading design systems tend to organize their design tokens into layers to support theme switching in a controlled, type-safe way. A common pattern is a multi-tier token architecture
bradfrost.com
bradfrost.com
. For example, Tier 1 tokens are raw values (color values, font sizes, etc.), Tier 2 tokens map those into semantic aliases for a theme (e.g. theme-color-primary or theme-border-radius), and Tier 3 tokens are component-level tokens (e.g. button-primary-background) that reference the Tier 2 theme tokens
bradfrost.com
. By separating core decisions from theme mappings, you can define multiple themes that plug into the same component structure. This is exactly how large systems (like Material Design or Atlassian) handle multiple color palettes or brands – the theme layer swaps out values while components stay agnostic to which theme is active. In a Tailwind + TypeScript context, maintaining type safety often means defining your tokens in TypeScript or JSON and ensuring the keys are consistent across themes. Some teams will define an ITokens interface or similar, so that each theme object adheres to the same shape (catching missing tokens at build time). Tailwind CSS v4 has introduced a CSS-first config with native CSS variables, which actually helps with type safety: Tailwind now uses the @property rule to register its internal CSS custom properties with types/constraints
dev.to
. This means your design tokens that become CSS variables can carry basic type information (e.g. a color variable is registered as <color> type). While this is mostly under-the-hood, it indicates an industry trend to use the browser’s type mechanisms for design tokens. In practice, many design systems still use tools like Style Dictionary to manage tokens externally and generate Tailwind config or CSS variable files from them
bradfrost.com
. The output is usually a set of :root CSS variables for each theme and corresponding Tailwind theme entries. Using CSS variables is the recommended approach in shadcn/ui as well (as noted in their docs) because it cleanly separates styling values from component logic
ui.shadcn.com
. Components use classes like bg-primary or text-foreground which map to --primary and --foreground CSS vars; switching theme means those variables produce different colors, without changing the component code
ui.shadcn.com
ui.shadcn.com
. For dynamic theme switching, maintaining type safety also involves careful naming conventions. Shadcn and others use a consistent naming scheme for variables (e.g. a -foreground suffix for text color paired with a background token)
ui.shadcn.com
ui.shadcn.com
. This ensures that if you have a --primary color, you also know to provide a --primary-foreground for contrast. By structuring tokens this way, you reduce the chance of a theme missing a critical value. Some systems even generate TypeScript definitions from their token files so that developers get autocompletion for token names. In summary, best practices here include: defining a clear token schema (possibly multi-tier), using CSS custom properties as the vehicle for runtime theme changes, and leveraging TypeScript or tailwind’s config to enforce consistency. As one author noted, “design tokens…represent key visual properties…like colors, typography, spacing… The goal is to centralize these design values so they can be easily updated, maintained, and shared”
dev.to
dev.to
 – a well-structured token system is what makes that possible.
Distributing Themes via JSON and the shadcn CLI
Shadcn’s CLI introduced a novel way to package and share components or themes as JSON files (the registry items). A registry:theme JSON file is essentially a bundle of design tokens (mostly CSS variables) that can be applied to a project. Real-world projects using this system often have separate JSON files for each theme. For example, a foundation-theme.json might look similar to the shadcn docs’ example-theme: it lists a schema URL, a name, type=registry:theme, and a cssVars section with color variables for light and dark mode
ui.shadcn.com
ui.shadcn.com
. This JSON can be consumed by running npx shadcn add <url-to-foundation-theme.json>, which instructs the CLI to merge those CSS variables into the project’s Tailwind setup. One successful pattern is to keep theme JSON files small and focused – typically just defining the variables and perhaps referencing a base style. (In the shadcn system, there’s a distinction between a style and a theme: a registry:style can include components or dependencies and can extend an existing style, whereas a registry:theme is usually just token overrides on top of an existing style
ui.shadcn.com
ui.shadcn.com
.) For instance, if your design system’s default style is installed, a theme JSON could simply override certain CSS variables (colors, fonts, sizes) without needing to duplicate component code. When distributing themes this way, it’s important to handle dependencies and variants in the JSON metadata. The schema allows specifying registryDependencies – for example, a theme might declare that it depends on the “default” style or a particular component set. This ensures that when a consumer installs the theme, the CLI will also pull in any required base components or styles
ui.shadcn.com
ui.shadcn.com
. Successful projects use this mechanism to layer themes: they might have a core components library (as one registry package) and separate theme packages that list the core as a dependency. Variant definitions (like different component styles for each theme) can be handled by the JSON as well, either via additional CSS in the css field or by providing theme-specific values that components read. For example, you could have a token like --radius (border radius) defined differently per theme, and your components use rounded-[var(--radius)] classes – switching the JSON theme changes all component radii. The shadcn JSON format even allows overriding Tailwind’s config values via CSS Vars. The official examples show a theme JSON adjusting Tailwind breakpoints and spacing by setting variables like --spacing or --breakpoint-sm in the cssVars.theme section
ui.shadcn.com
. This means you can distribute not just colors but also typographic scale, spacing scale, etc., as part of the theme. Registry metadata is another consideration. Each JSON item has fields like name, description, maybe an author, and so on
github.com
github.com
. Best practices here are to give each theme a clear name (e.g. “NOLA Foundation Theme”), a description of when/where to use it (e.g. “High-contrast theme for early learners”), and version or author info if applicable. While the registry JSON schema doesn’t natively include a version field for each item (it could be managed at the registry level), you can include version info in the description or use source control tags. Projects running their own registries often maintain a registry.json index file that lists all available items (components, themes, etc.) with their metadata
vercel.com
. For distribution via shadcn CLI, it’s crucial to host these JSON files in a stable URL (for example on GitHub raw or a static site). Some teams even set up a private registry with authentication if the design system is internal
vercel.com
. In summary, the JSON + CLI approach works best when you: keep theme definitions lean (mostly CSS custom properties), declare any dependencies explicitly, and document each theme in the JSON metadata so consumers know how to pick and use them.
Theme Preview and Switching in Storybook (v9)
Showing multiple themes side-by-side in documentation is essential for an educational design system. Storybook v9 provides an official addon called Themes for exactly this purpose
storybook.js.org
. The addon introduces decorators that allow stories to be wrapped with theme providers, or to toggle CSS classes or attributes to simulate themes. For Tailwind-based theming (like shadcn’s, which typically uses a class="dark" on <html> for dark mode), the simplest method is using the withThemeByClassName decorator. In Storybook’s .storybook/preview.ts you can add:
import { withThemeByClassName } from '@storybook/addon-themes';

export const decorators = [
  withThemeByClassName({
    themes: {
      light: '',       // no class for default light theme
      dark: 'dark',    // add class="dark" for dark theme
      sepia: 'sepia'   // example additional theme class
    },
    defaultTheme: 'light',
    classTarget: 'html' // apply the class to the html element
  })
];
This will add a theme picker in the Storybook toolbar so viewers can switch between “light”, “dark”, “sepia”, etc., and Storybook will apply the corresponding class to the preview iframe’s <html> element
storybook.js.org
storybook.js.org
. The classTarget can be adjusted depending on where in your app you apply theme classes (often it's the html or body). Many design systems using Tailwind/dark-mode adopt this exact pattern – it’s also reflected in community examples. For instance, a 2024 blog post on using Shadcn UI with Storybook shows how they configured @storybook/addon-themes and used withThemeByClassName to toggle Tailwind’s light/dark classes
dev.to
dev.to
. The addon handles ensuring the styles update on the fly as you toggle themes in the UI. For design systems with context-based theming (e.g. using a React Context or styled-components ThemeProvider), Storybook’s addon offers withThemeFromJSXProvider which can wrap stories in a theme provider
storybook.js.org
storybook.js.org
. However, since our stack is Tailwind + CSS variables, we likely won’t use a context provider for theme – we’ll use the CSS class method. In Storybook 9, it’s also possible to display multiple themes side by side by using the Docs view and writing custom MDX that shows a component in multiple framed divs each with a different class. But an easier approach is to use Storybook’s “copy as new” canvas view feature or simply switch using the toolbar (since the addon-themes preserves state as you navigate stories). Beyond the addon, some design systems implement a custom dropdown or knobs to switch themes. In older Storybook versions one might have used a decorator that injects a <div data-theme="X"> around each story (for DaisyUI style theming). The modern addon covers this via withThemeByDataAttribute if you prefer data attributes
storybook.js.org
storybook.js.org
. For example, if using DaisyUI themes, you could do withThemeByDataAttribute({ themes: { foundation: 'foundation', pathways: 'pathways' }, defaultTheme: 'foundation', attributeName: 'data-theme' }). This would toggle a data-theme="pathways" on the preview, and DaisyUI’s CSS would respond accordingly. In summary, Storybook v9 best practice is to use the Themes addon. It’s well-maintained and supports Tailwind class-based themes out of the box. We can integrate it such that our Storybook has a theme switcher for “Foundation / Pathways / Professional (light/dark)” etc., allowing stakeholders to preview components under each theme. This is important for verifying our color contrasts and stylistic differences in an isolated environment. The addon approach ensures that the theme switching is done consistently for all stories (using a global decorator), so we don’t need to manually duplicate stories for each theme – the user can toggle at will
dev.to
dev.to
.
Exporting and Packaging Themes for External Use
When it comes to distributing the themes to actual applications (outside of our Storybook), there are a few proven strategies. One approach is to package each theme as an NPM module (or a single file) that contains the CSS variables and any Tailwind configuration needed. For example, some multi-theme design systems publish a small CSS file for each theme – including the :root (or [data-theme="X"]) definitions of all variables for that theme, plus perhaps a Tailwind plugin/preset if needed. Consumers can then import this CSS (and ensure it’s loaded before the rest of the app’s styles) to apply the theme. This is similar to how Material UI or Bootstrap themes are distributed (you include a different CSS file to get a different color scheme). However, since our system is built with Tailwind, a more Tailwind-native solution is to use presets or plugins. The multi-brand system by Thinkmill illustrates using a Tailwind preset: they created a createPreset(tokens) utility that returns a Tailwind config object for the given brand tokens, and consumers simply add that to their Tailwind config presets array
thinkmill.com.au
. This bundles in all the theme values (colors, etc.) at build time. The advantage of a preset is that it can also add the necessary layers (for example, injecting @layer base with CSS variables, or custom utilities) in the correct order. Thinkmill’s preset, for instance, injects base styles like the CSS variable definitions and resets, then merges in theme-specific extensions (colors, radii, etc.), and even allows toggling Tailwind’s default utilities on/off
thinkmill.com.au
thinkmill.com.au
. By packaging theme logic in a preset, they ensure consistent layer ordering every time someone uses that theme. Our design system could adopt a similar pattern: e.g. an NPM package @nola-ds/theme-foundation that exports a Tailwind preset or plugin. Developers installing it would add it to their Tailwind config, and it would automatically apply the correct CSS variables and theme values. Another best practice example is DaisyUI, which is distributed as a Tailwind plugin. DaisyUI’s plugin adds not only components but also its theming system. It defines multiple themes via an API in the tailwind config (or via import in CSS) and generates the CSS for them. The key idea is that DaisyUI uses CSS variables and semantic tokens, so the incremental cost of adding themes is small – you’re mostly adding sets of variable values, not duplicating all the component styles
daisyui.com
. DaisyUI allows users to configure which themes to include (to avoid bundling all 35 by default), and it registers an @plugin that injects theme definitions at the base layer
daisyui.com
daisyui.com
. We can take inspiration from this: for example, we could provide a Tailwind plugin that installs our design system (like shadcn’s components) plus theme tokens. Or, since we already use shadcn’s CLI approach, we might simply ensure that when someone installs our component library via CLI, they also get a theme JSON (or can choose one). The shadcn registry starter template suggests that to use a custom theme, you just modify the globals.css tokens and Tailwind config
vercel.com
. For distribution, they note that the registry’s first item is usually the theme, containing both Tailwind config and design tokens
vercel.com
. That means when someone initializes your registry, they get the theme by default. In terms of CSS layer ordering and PostCSS: when packaging themes, we have to ensure that our CSS variables (which likely go in :root or .dark classes) are output in Tailwind’s base layer (so that utilities can reference them). Tailwind handles this if we use the config or plugin correctly – e.g. adding entries to the theme in Tailwind config for colors will cause it to generate the @layer base { :root { --color: ... } } definitions. If we manually write CSS (like in a JSON registry item or in a preset), we should put it in @layer base for variables, @layer components for any component default styles, and @layer utilities for any custom utilities
thinkmill.com.au
thinkmill.com.au
. Maintaining this order avoids specificity issues. PostCSS can then process the final CSS – typically our pipeline will include Autoprefixer and maybe cssnano for minification – but no special PostCSS magic is needed beyond what Tailwind already does. If anything, one might use PostCSS to scope themes (for example, DaisyUI’s use of :root vs [data-theme] selectors could be abstracted by PostCSS, but DaisyUI actually handles it via a plugin). Finally, a note on distributing via JSON for the CLI: That is also a form of packaging – essentially our “package” is the JSON file plus any referenced files. The CLI will generate the actual code in the target project. So, we must maintain those JSON files much like we would an npm package – version control them, test them, and update the schema if needed. The nice part is that JSON is framework-agnostic and can be hosted anywhere; the trade-off is that consumers need to use the shadcn CLI to pull it in. For wider adoption, providing an npm package with pre-built CSS might be easier for some users not using the CLI. Many successful design systems actually offer both: a raw CSS/JS bundle for quick use and a more structured token/package setup for deeper integration. Depending on our audience, we might do the same.
Educational and Age-Appropriate Theming Considerations
Designing themes for educational contexts (especially catering to different age groups) introduces additional best practices around accessibility and usability. One key principle is ensuring the themes are inclusive and meet WCAG guidelines. For instance, young children or early readers benefit from high-contrast text, larger font sizes, and simple typography
portotheme.com
. Our “Foundation” theme (if aimed at younger learners) might use extra-large text and very clear, distinguishable colors. Research in educational UX suggests using bright, engaging colors to hold kids’ attention, but also cautions against overly saturated palettes that can cause eye strain
portotheme.com
. A good balance is to pick a vibrant palette that still passes contrast checks. Many educational design systems choose slightly softer background colors with bright accent hues for interactive elements – this creates a friendly feel without sacrificing readability. For age-appropriate design, it’s recommended to adjust visual density and complexity for different age ranges. Younger users (e.g. ages 3–5) need very simple visuals, lots of spacing, and minimal text, whereas older students can handle more information on screen
portotheme.com
. In theming terms, that could mean the “Pathways” theme (middle grade, for example) might introduce a tighter spacing scale and smaller type than the Foundation theme, but still larger and more open than a typical professional/corporate theme. We can achieve this by defining different spacing and sizing tokens per theme – e.g. --spacing-3 might be 0.75rem in Foundation (for big gaps) but 0.5rem in Professional. Similarly, our themes should account for interaction states that are suitable for all ages: for kids, focusing states might be more pronounced (maybe a thicker outline or a friendly glow) so that they can easily see what’s focused. Accessibility is crucial in education. By 2025, there’s a strong emphasis that accessibility is not optional in educational software
kalamuna.com
. This means all our theme variants should adhere to contrast ratios (we should test both light and dark text on our background colors), and consider colorblind-safe palettes if possible. Also, consider motion and distractions: young or neurodiverse users can be sensitive to motion, so if our theme includes any animated aspects or very bright colors, providing a “reduced motion” or subdued mode is a good idea. While that might not be a separate theme, it’s something to integrate (via prefers-reduced-motion CSS or a toggle). There are also WCAG 2.2 updates that emphasize things like focus visibility (we need distinct focus styles, especially since keyboard navigation might be used by some learners with motor disabilities) and target sizes. The design system should ensure that in every theme, interactive elements are sufficiently large – the guidelines often mention a minimum of 44x44px touch target for touch devices
portotheme.com
. Our theme tokens for sizing (button padding, etc.) should be set with this in mind, particularly for younger age themes where users are likely on tablets or small screens. Another consideration is imagery and tone: an educational theme might incorporate more playful iconography or illustrations. While that’s more about content than the system tokens, we can facilitate it by having tokens for illustration styles or using a slightly different component style (e.g. a “fun” avatar or mascot on some components in the younger theme). For example, a theme could include a background pattern or a set of preset illustrations that align with it – those aren’t purely Tailwind tokens, but we could distribute them as part of the theme assets. In summary, the latest techniques for educational theming involve responsive, adaptive design that can tailor itself to the user’s needs and age. This means using our theming system to provide: high contrast mode (or simply high contrast colors by default for little ones)
portotheme.com
, clear and consistent color cues (e.g. using one highlight color for all clickable elements so children learn the cue)
portotheme.com
, reduced complexity in visuals for younger themes (lots of white space, larger elements)
portotheme.com
, and adherence to accessibility features like alt-text for icons and no reliance on color alone for meaning. Thankfully, implementing these is a matter of defining our theme tokens carefully (for example, choosing color pairs that are far apart in luminance for contrast, and setting base font-sizes larger in the CSS vars for Foundation theme). As one UX guideline states, emerging readers need large fonts and simple vocabulary, visually impaired children need high contrast, and neurodiverse users benefit from predictable, non-flashy UIs
portotheme.com
. We should use those principles as guardrails when fine-tuning each theme’s design tokens.
Theme Versioning and Backwards Compatibility
Distributing themes through a component registry or any package means we have to manage versioning so that updates don’t break consuming apps unexpectedly. Industry best practices in 2025 treat design tokens and themes similarly to code: using semantic versioning and clear changelogs. For example, if we change a primary color value or rename a token, that’s considered a breaking change – it might affect many components’ appearance. Teams handle this by batching such changes into major version releases of the theme. A 2025 article on design token management put it simply: “What if a single token change breaks 20 apps? … This is where token versioning comes into play.”
designsystemscollective.com
designsystemscollective.com
. They recommend tracking what changed, when, and who for each token update, much like git for code
designsystemscollective.com
. Practically, for us this could mean maintaining a CHANGELOG.md for our themes and using tags (v1.0, v2.0, etc.) in whichever distribution medium (npm or git for JSON). Shadcn’s CLI registries don’t inherently version the JSON items (there’s no built-in version field in the JSON), so we might manage versioning at the registry level. One approach is to publish a new URL or identifier for a new major theme version – e.g. foundation-v2.json – so that it doesn’t automatically override existing projects that are pointed at v1. Another approach is to use the git commit hash or a query param in the URL to pin versions. The shadcn CLI currently pulls the latest by default if you point to a raw GitHub URL (unless you fix to a commit), so we’d likely document that consumers should pin to a specific commit/tag if they want stability. This is analogous to how one would lock a package version. Some teams running custom registries have started implementing registry versioning by namespace or branch (for example, having a “v1” registry and a “v2” registry endpoint). If our design system is widely used, we might consider that approach as we mature. To maintain backwards compatibility, it’s common to deprecate tokens gradually rather than remove them outright. For instance, if we want to rename --brand-color to --primary in the theme, we might release a version where both exist (one perhaps aliasing the other), mark --brand-color as deprecated in docs, and only remove it in the next major version. This soft transition is easier on consuming apps. Some design systems also provide migration guides or codemods for theme upgrades. Because tokens are often used directly in classnames (for Tailwind, developers might use classes like bg-[--customToken]), a rename can be a big refactor. Communicating these changes clearly is key. Another strategy is theming via composition for upgrades: For example, Brad Frost mentions supporting “multiple generations of a design language” by having parallel themes
bradfrost.com
. You could have a “Legacy” theme and a “New” theme that both work with the same components. Consumers could switch when ready. In code, this might mean our component library can accept a prop or class to apply the new theme (or they install the new theme package). The old theme might still be maintained for a while to support older designs. We see this pattern in frameworks like Material Design (where MD2 and MD3 themes coexist). For us, since we’re doing CSS variables, we could conceivably allow both sets of variables – but that gets messy. It’s cleaner to allow only one active theme at a time, and ask projects to upgrade in one go, but we can smooth that by releasing an intermediate version. In summary, to manage theme versioning: use semantic versioning for theme releases (update the version any time tokens change significantly), maintain a changelog highlighting token additions, removals, or value changes, and consider providing tools or documentation to help migrate. When breaking changes occur, communicate what old tokens should be replaced with (e.g. “token --bg-primary removed in favor of --background”). By treating the theme as a versioned API, we ensure consuming developers aren’t caught off guard. And if using the shadcn CLI registry, possibly leverage the registry’s metadata to note compatibility (for example, a theme might note it requires component library version X). This extra metadata isn’t built-in, but can be included in docs or the description. The goal is to avoid reinventing the wheel in each consuming project – if we handle versioning well, developers can confidently update to get new theme improvements with minimal friction.
Performance Optimizations for Multi-Theme Support
Supporting multiple themes can sometimes increase bundle size or runtime cost, but there are best practices to mitigate this. A core strategy is to avoid duplicating CSS across themes. Instead of, say, generating a whole new set of utility classes for each theme (which would multiply your CSS output), use CSS variables or contextual selectors to toggle theme values. Tailwind CSS’s upcoming features and plugins align with this: for example, the tailwindcss-themer plugin allows you to define multiple themes in your config and automatically creates variants that apply only when a certain class (like .theme-dark) is present. Notably, it uses CSS custom properties internally so that you only define your base styles once – the different themes just swap out the variables’ values
github.com
. The plugin author emphasizes that this approach “lets you declare styles once” and have unlimited themes, with minimal bundle size impact
github.com
github.com
. We can apply the same philosophy manually: define our component styles generically (using the custom properties) and then define each theme’s variables in a scoped manner. For example, in our CSS we might have:
:root {
  --background: ...; --foreground: ...; /* foundation default */
}
.theme-pathways {
  --background: ...; --foreground: ...; /* overrides for pathways */
}
/* component styles */
.card { background-color: var(--background); color: var(--foreground); }
In this approach, the .card styles are written once. The additional cost per theme is just a few lines of CSS inside the theme scope (the variables). This is extremely cheap in terms of CSS size. If we had instead duplicated .card styles with different classes (like .pathways .card { ... }), that would scale linearly with number of themes – not ideal. By sticking to variables, adding a new theme only costs O(number of tokens) CSS. We saw earlier that DaisyUI follows this method: “daisyUI semantic color names are using CSS variables… so you can change the theme by changing the value of these variables. You can also have multiple themes at the same time without adding a single class name.”
daisyui.com
. This variable-driven theming is a huge performance win. Another optimization is to tree-shake unused themes. If our design system offers 3 themes but an application only uses one (and doesn’t allow user switching), then ideally the other themes’ CSS shouldn’t be included. With Tailwind JIT, any CSS that isn’t referenced in the HTML/JSX won’t be generated. So if an app never uses the class theme-pathways or never sets data-theme="professional", the corresponding CSS might get dropped (depending on how it’s integrated). If we distribute themes via a plugin or preset, we could offer a config option to include only specific themes. DaisyUI does this by letting you specify an array of theme names in the Tailwind config; if you don’t, it includes all by default
daisyui.com
daisyui.com
. We can mimic that by perhaps having separate imports or an environment variable to control it. For our own use (Storybook, etc.), we’ll include all themes, but we can guide consumers to only pull what they need. On the Next.js side (Next.js 15.x), performance considerations also include CSS loading and hydration. Next.js will merge and minify the Tailwind output. Using multiple themes doesn’t significantly affect runtime execution – it’s mostly static CSS. However, if we allow dynamic theme switching on the client, then we should be mindful of the strategy: toggling a class on the root (for Tailwind dark mode or theme classes) is very fast – just one DOM update – and the CSS is already loaded, so that’s fine. If we instead opted for loading an alternate CSS file on demand (e.g. user selects a theme and we fetch its CSS), that adds a network request and render delay. Most modern apps therefore include both light and dark theme styles in one bundle and switch by class, which is the pattern we’ll likely use for our multiple themes as well (especially since educational software might let a user choose a theme). The impact on bundle size is minimal if done via variables as described. To quantify, if each theme has, say, 50 custom properties, and we have 3 themes, that’s at most a couple hundred lines of CSS extra – which is trivial. The heavy part of CSS – all the utility classes – remain single-instance. Our use of Tailwind’s JIT means if a utility class (like bg-primary) is used, it generates one rule that references --primary. It doesn’t matter how many themes we have; that rule stays the same. Only the --primary value changes per theme scope. This is very efficient. It’s a battle-tested pattern now: even multi-tenant platforms use Tailwind v4 with CSS variables to host dozens of theme variations without blowing up bundle size
wawand.co
github.com
. Lastly, consider purging and caching: we should ensure that our themes are considered in the purge content if needed (Tailwind will catch classes like dark or custom theme classes if we include them in content or safelist). We should also document that if someone isn’t using a theme, they can remove its classes to let purge drop it. Next.js will automatically code-split by page, but since theme CSS is global, it will be loaded site-wide (which is what we want for consistency when switching theme on any page). In summary, by using CSS custom properties and minimal duplication, we can support multiple themes with negligible performance overhead. Modern CSS and Tailwind techniques ensure that we don’t ship three times the CSS for three themes – we ship base styles once and just variable tweaks per theme. This keeps our Next.js app fast and the CSS bundle slim. (For reference, a Tailwind plugin author noted their theming approach “reduces bundle size” and “doesn’t duplicate all of your styles for each theme”
github.com
, which aligns with our plan.)
Testing Strategies for Themed Components
Testing a multi-theme design system is crucial to catch inconsistencies. A common best practice is to perform visual regression testing across all themes. Tools like Chromatic (by Storybook) are popular – Chromatic will take snapshots of each story in our Storybook and can be configured to do so for each theme variant, flagging any unintended differences
chromatic.com
. In fact, Chromatic’s documentation mentions it can test across “browsers, viewports, and themes” automatically
chromatic.com
. We could set up our Storybook with the theme toggle and then have Chromatic generate snapshots for “Foundation – Button”, “Pathways – Button”, “Professional – Button” etc., ensuring that changes we make don’t break one theme’s appearance. This is extremely useful when refactoring or updating tokens – it’s easy to inadvertently impact spacing or alignment in one theme. Apart from visual tests, we should also do functional testing of themes. This might include unit or integration tests that verify certain tokens meet criteria. For example, we could write tests that programmatically compute contrast ratios of our foreground and background CSS variables for each theme and assert they meet WCAG 2.1 AA standards. There are libraries (or we can write a small script) to fetch computed styles in a headless browser and run contrast formulas. This kind of test guards our accessibility goals – if someone accidentally set a light gray text on white background in the “Professional” theme, a contrast test could catch that before release. Moreover, if our components have logic that depends on theme (not usually, since mostly it’s pure styling, but perhaps an SVG icon that is different in a dark theme), we would test those conditions. However, generally we strive to keep components theme-agnostic (they just consume CSS vars). So the main testing is visual and tokens. Using Storybook addons for a11y (accessibility) can also help – Storybook’s accessibility addon can run axe checks on each story. We should run those for each theme, because color contrast checks are theme-dependent. For example, the Storybook a11y addon would flag if text is not sufficiently contrasty on the background in a given theme. Another effective strategy is snapshot testing for class combinations. For instance, we can render a Button in each theme and snapshot the DOM/CSS classes to ensure the right classes are applied (this mostly tests our theming mechanism rather than visual output). But since theming in our case is mostly CSS variables, a better approach is to use visual regression as mentioned. Some teams have also used Percy or Loki for visual testing with their Storybooks. The key is to automate it so that when we change something, we don’t have to manually check 3 themes * X components by eye. In CI/CD, we will likely integrate these tests so that any discrepancy must be reviewed. For example, Chromatic will highlight a button moved 2px or a color shift if a token changed, and we can accept or reject that change knowing its impact. This process has been embraced by many design system teams as it gives confidence in refactoring. Finally, we shouldn’t ignore manual testing with assistive tech. It’s worth manually toggling through themes with a screen reader and keyboard navigation to ensure focus states are always visible (e.g., a focus ring might be a theme token – we need to ensure it’s not lost in any theme background). Also test high contrast mode if on Windows (our design might not explicitly have a high-contrast theme, but users might force a high-contrast setting; we should see that our app doesn’t become unusable). In summary, a combination of automated visual regression (using tools like Chromatic
chromatic.com
), automated accessibility checks, and selective unit tests for token values will give us a robust safety net. Given that themes primarily affect CSS, visual tests are the most direct way to validate that “what you see” remains correct across changes.
Emerging Patterns for Theme Composition and Extension
As of 2025, an emerging theme in design systems is flexibility: allowing consumers (the end developers using the system) to customize or extend themes without breaking the upgrade path. One pattern gaining traction is to provide a base theme (or multiple base themes) that can be extended via additional tokens. Brad Frost describes how some systems handle sub-brands or white-label needs by essentially layering another theme on top of the base
bradfrost.com
bradfrost.com
. In practice, this could mean our design system offers a default theme (say “Foundation”), and if a consumer wants to tweak it (maybe their school district has a specific brand color), they can supply a small set of overrides – a theme extension. Because we structured our theming with CSS variables, a consumer can simply override those CSS variables in their application’s CSS (after our imports) to adjust the theme. For example, they could set :root { --primary: <their color>; --primary-foreground: <computed contrasting color>; } and everything using our components would update to that primary color. This is the simplest form of extension. However, a more formal pattern is emerging: token merging. Some design systems provide their token definitions as data (JSON or TS objects) and allow consuming teams to merge in their own values and then regenerate the CSS. Style Dictionary is often used here – a company might take our foundation.json tokens, override a few entries (like change the logo or accent color), then build their own theme file. Because our system is type-safe and documented, they know exactly which tokens to override. Maintaining the same structure across themes is what makes this safe: if we add new tokens in an update, their extended theme can simply inherit those (or use our defaults) without issue. It’s similar to how one might extend a class in OOP – the child theme inherits everything from base unless it overrides. In our context, a consumer could create a custom registry item (if using shadcn CLI) that extends our theme. In the shadcn JSON schema, a registry:style item can have "extends": "<name of base style>"
ui.shadcn.com
. So a potential scenario: we publish foundation-style.json (type registry:style with all base components and default tokens), and a consumer writes their own my-theme.style.json with "extends": "foundation" and just a cssVars section of changes. The CLI would then merge those – installing foundation first, then applying their overrides. This is powerful and something we want to encourage because it prevents forking the whole design system just to change a few colors. Another pattern is composition through preset chains. We saw hints of this in multi-brand systems: “the design system team publishes the themes, and consumers pull in the core + brand theme into their product”
bradfrost.com
bradfrost.com
. The notion of core tokens plus brand-specific tokens means that if our system has some common tokens (maybe layout metrics, typography scale) and then theme-specific ones (colors, maybe font families), we can separate those. Consumers then mix-and-match: e.g. use NOLA’s core + NOLA’s “HighContrastColors” theme if they want a high-contrast variant for accessibility. Composable themes like this are emerging – it’s somewhat advanced, but imagine themes as modules: one could import a color module, a spacing module, etc. Tailwind’s new @layer and CSS variable capabilities make this feasible by simply adding or overriding CSS vars in incremental fashion. From the perspective of upgrade paths, enabling customization means we have to document what parts of the theme are safe to override. For instance, we might say: you can change the color tokens, but if you change spacing scale, be cautious because our components are designed around those values. If a user does extend a theme, a future update from us that changes component structure could affect how their override behaves. A best practice is to keep extensions additive or scoped – e.g., allowing adding a new color or maybe providing a “theme slot” token (like --brand-color) specifically meant for consumers to override, while we guarantee not to repurpose that token for something else. Some systems have the concept of “CSS variables API”, essentially treating certain CSS vars as public API that others can tweak, while others are internal. We can adopt that concept: document which variables are intended for user theming (perhaps brand colors, logo images, etc.) and which are tied to internal design decisions (like grayscale neutrals maybe should not be overridden heavily, or at least not without testing). Emerging tools: We see theme editors (some even mentioned in the shadcn community, like “tweakcn” theme editor) that let you visually adjust shadcn theme colors and output a JSON
github.com
github.com
. This indicates an ecosystem where users of design systems expect to be able to create custom themes easily. Providing a good structure and possibly a CLI or GUI for our themes would follow this trend. For instance, we could create a Figma or an online tool where someone picks new colors for “Professional” theme to match their branding, and then we give them the JSON or Tailwind config to plug in. To summarize, the pattern is modularity and clear extension points. Our design system should allow a consumer to compose their own theme from ours by overriding a minimal set of tokens, ideally without copying all our code. Whether through the shadcn registry extension, using CSS override in their app, or by merging token definitions via a build tool, we want to support it. This way, we maintain the single source of truth (they still rely on our core for updates), and their customizations sit on top. Many modern design systems encourage this to increase adoption – not every user will accept a stock theme, but if they can easily theme it to their needs, they’re more likely to use the system rather than reinvent components. In conclusion, by studying these best practices and examples from 2024-2025, we can implement a robust multi-theme architecture for the NOLA Design System. We’ll leverage Tailwind’s strengths (utility classes + CSS vars), shadcn’s registry for distribution, and ensure that our themes are well-structured, accessible, and easy to consume or extend. This avoids reinventing the wheel – instead we stand on the shoulders of proven design system solutions as we build out our educational theming system. Sources:
Tailwind CSS & Shadcn UI multi-theme examples
thinkmill.com.au
ui.shadcn.com
Thinkmill multi-brand design system insights
thinkmill.com.au
thinkmill.com.au
Shadcn/UI theming and registry documentation
ui.shadcn.com
ui.shadcn.com
DaisyUI theming approach (semantic color vars, multiple themes)
daisyui.com
daisyui.com
Storybook addon for themes (v9) usage
storybook.js.org
dev.to
Tailwindcss-themer plugin (multi-theme without duplicate styles)
github.com
github.com
UX best practices for children (colors, contrast, sizes)
portotheme.com
portotheme.com
Design tokens and theme versioning commentary
designsystemscollective.com
designsystemscollective.com
Brad Frost’s themeable design systems (token tiers, layering themes)
bradfrost.com
bradfrost.com
Chromatic for visual testing across themes
chromatic.com
 and Storybook a11y checks.
